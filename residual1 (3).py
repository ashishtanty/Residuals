# -*- coding: utf-8 -*-
"""Residual1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MBHHthI2JPJ-Bz7qXhZV2ig9DEfpSKFj
"""

#1st code
import numpy as np
import matplotlib.pyplot as plt
def defocus_zernike(r,theta,a):
  return (2*r**2-1)*a
a=5.7
a1=np.linspace(4,8,50)
a_new = np.array(a1)
Res = np.abs(a_new - a)
#plt.plot(a1, Res, marker='.')
plt.scatter(a1,Res, marker = '.')
plt.xlabel("Zernike Coeff(defocus)")
plt.ylabel("Residuals")
plt.title(" Defocus ")

#2nd code
import numpy as np
import matplotlib.pyplot as plt

a1_vals = np.linspace(4, 8, 10)
a2_vals = np.linspace(4, 8, 10)
a3_vals = np.linspace(4, 8, 10)

a1_t = 4.8
a2_t = 5.8
a3_t = 6.8

Res = []

for a1 in a1_vals:
    for a2 in a2_vals:
        for a3 in a3_vals:
            res = abs(a1 - a1_t) + abs(a2 - a2_t) + abs(a3 - a3_t)
            Res.append(res)

Res = np.array(Res)

# iterations
iteration = np.arange(len(Res))

plt.scatter(iteration, Res,s=1, marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual (Coefficient Difference)")
plt.title("Iteration vs Residual(Def,ComaX,ComaY)")
plt.show()

#3rd code
import numpy as np
import matplotlib.pyplot as plt
def Zernike(r, theta, a1, a2, a3):
    return (a1 * (2*r**2 - 1) +
            a2 * r**2 * np.cos(2*theta) +
            a3 * r**2 * np.sin(2*theta))

r_val = 1.0
theta_val = 0.0

a1_coeffs = np.linspace(4, 8, 10)
a2_coeffs = np.linspace(4, 8, 10)
a3_coeffs = np.linspace(4, 8, 10)

Zernike_values = []
for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:
            val = Zernike(r_val, theta_val, a1, a2, a3)
            Zernike_values.append(val)

Zernike_values = np.array(Zernike_values)

a1_t = 4.8
a2_t = 5.8
a3_t = 6.8

target = Zernike(r_val, theta_val, a1_t, a2_t, a3_t)

Res = np.abs(Zernike_values - target)

iteration = np.arange(len(Res))
plt.scatter(iteration, Res, s= 2, marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual")
plt.title("Iteration vs Residual (Zernike-Based)")
plt.grid(True)
plt.show()

#4th code
import numpy as np
import matplotlib.pyplot as plt
N = 256
x = np.linspace(-1, 1, N)
y = np.linspace(-1, 1, N)
X, Y = np.meshgrid(x, y)
r = np.sqrt(X**2 + Y**2)
theta = np.arctan2(Y, X)
mask = r <= 1

def Wavefront(a1, a2, a3):
    return (a1*(2*r**2 - 1) +
            a2*r**2*np.cos(2*theta) +
            a3*r**2*np.sin(2*theta))

def PSF(a1, a2, a3):
    W = Wavefront(a1, a2, a3)
    phase = 2*np.pi * W * mask
    P = mask * np.exp(1j * phase)
    PSF = np.abs(np.fft.fftshift(np.fft.fft2(P)))**2
    return PSF / PSF.max()

a1_t = 4.9
a2_t = 6.2
a3_t = 6.8

PSF_target = PSF(a1_t, a2_t, a3_t)

a1_vals = np.linspace(4, 8, 10)
a2_vals = np.linspace(4, 8, 10)
a3_vals = np.linspace(4, 8, 10)

residuals = []

for a1 in a1_vals:
    for a2 in a2_vals:
        for a3 in a3_vals:
            psf_new = PSF(a1, a2, a3)


            res = np.sum(np.abs(psf_new - PSF_target))
            residuals.append(res)

residuals = np.array(residuals)
iterations = np.arange(len(residuals))

plt.figure(figsize=(7,4))
plt.scatter(iterations, residuals, s=2)
#plt.xlim([80,200])
plt.xlabel("Iteration")
plt.ylabel("Residual (PSF difference)")
plt.title("Iteration vs PSF Residual")
plt.grid(True)
plt.show()

#5th code
import numpy as np
import matplotlib.pyplot as plt
N = 256
x = np.linspace(-1, 1, N)
y = np.linspace(-1, 1, N)
X, Y = np.meshgrid(x, y)
r = np.sqrt(X**2 + Y**2)
theta = np.arctan2(Y, X)
mask = r <= 1

def Wavefront(a1, a2, a3):
    return (a1*(2*r**2 - 1) +
            a2*r**2*np.cos(2*theta)+
            a3*r**2*np.sin(2*theta))

def PSF(a1, a2, a3):
    W = Wavefront(a1, a2, a3)
    phase = 2*np.pi * W * mask
    P = mask * np.exp(1j * phase)
    PSF = np.abs(np.fft.fftshift(np.fft.fft2(P)))**2
    return PSF / PSF.max()

a1_t = 4.8
a2_t = 5.8
a3_t = 6.8

PSF_target = PSF(a1_t, a2_t, a3_t)

a1_vals = np.linspace(4, 8, 10)
a2_vals = np.linspace(4, 8, 10)
a3_vals = np.linspace(4, 8, 10)

residuals = []

for a1 in a1_vals:
    for a2 in a2_vals:
        for a3 in a3_vals:
            psf_new = PSF(a1, a2, a3)


            res = np.sum(np.abs(psf_new - PSF_target))
            residuals.append(res)

residuals = np.array(residuals)
iterations = np.arange(len(residuals))

plt.figure(figsize=(7,4))
#plt.scatter(iterations, residuals, s=2)
plt.plot(iterations, residuals,color='r',marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual (PSF difference)")
plt.title("Iteration vs PSF Residual")
plt.grid(True)
plt.show()
records = []

for a1 in a1_vals:
    for a2 in a2_vals:
       for a3 in a3_vals:
        psf_new = PSF(a1, a2, a3)
        res = np.sum(np.abs(psf_new - PSF_target))
        records.append((a1, a2, a3, res))

records = np.array(records, dtype=float)

min_index = np.argmin(records[:,3])
a1_min, a2_min, a3_min, res_min = records[min_index]

print("Global minima occurs at:")
print(f" a1 = {a1_min}")
print(f" a2 = {a2_min}")
print(f" a3 = {a3_min}")
print(f" residual = {res_min}")

#6th code
import numpy as np
import matplotlib.pyplot as plt

N = 256
x = np.linspace(-1, 1, N)
y = np.linspace(-1, 1, N)
X, Y = np.meshgrid(x, y)
r = np.sqrt(X**2 + Y**2)
theta = np.arctan2(Y, X)
mask = r <= 1

def Wavefront(a1, a2, a3):
    return (a1*(2*r**2 - 1) +
            a2*r**2*np.cos(2*theta) +
            a3*r**2*np.sin(2*theta))


def PSF(a1, a2, a3):
    W = Wavefront(a1, a2, a3)
    phase = 2*np.pi * W * mask
    P = mask * np.exp(1j * phase)
    psf = np.abs(np.fft.fftshift(np.fft.fft2(P)))**2
    return psf / psf.max()


a1_t = 4.8
a2_t = 5.8
a3_t = 6.8

PSF_target = PSF(a1_t, a2_t, a3_t)

a1_vals = np.linspace(4, 8, 10)
a2_vals = np.linspace(4, 8, 10)
a3_vals = np.linspace(4, 8, 10)

# Store results: (a1, a2, a3, residual)
records = []

for a1 in a1_vals:
    for a2 in a2_vals:
        for a3 in a3_vals:
            psf_new = PSF(a1, a2, a3)
            res = np.sum(np.abs(psf_new - PSF_target))
            records.append((a1, a2, a3, res))

records = np.array(records, dtype=float)


residuals = records[:, 3]
iterations = np.arange(len(residuals))

plt.figure(figsize=(7, 4))
plt.plot(iterations, residuals, marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual (PSF difference)")
plt.title("Iteration vs PSF Residual")
plt.grid(True)
plt.show()


min_index = np.argmin(residuals)

a1_min, a2_min, a3_min, res_min = records[min_index]

print("\nGlobal minima occurs at:")
print(f"  a1 = {a1_min}")
print(f"  a2 = {a2_min}")
print(f"  a3 = {a3_min}")
print(f"  residual = {res_min}")
print(f"  iteration number = {min_index}")

#7th code
import numpy as np
import matplotlib.pyplot as plt
N = 256
x = np.linspace(-1, 1, N)
y = np.linspace(-1, 1, N)
X, Y = np.meshgrid(x, y)
r = np.sqrt(X**2 + Y**2)
theta = np.arctan2(Y, X)

def Zernike(r, theta, a1, a2, a3):
    return (a1 * (2*r**2 - 1) +
            a2 * r**2 * np.cos(2*theta) +
            a3 * r**2 * np.sin(2*theta))

a1_coeffs = np.linspace(4, 8, 10)
a2_coeffs = np.linspace(4, 8, 10)
a3_coeffs = np.linspace(4, 8, 10)

a1_t = 4.8
a2_t = 5.8
a3_t = 6.8

target = Zernike(r, theta, a1_t, a2_t, a3_t)

residuals_list = []
for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:

            current_zernike = Zernike(r, theta, a1, a2, a3)

            res_val = np.sum(np.abs(current_zernike - target))
            residuals_list.append(res_val)

Res = np.array(residuals_list)

iteration = np.arange(len(Res))
plt.scatter(iteration, Res, s= 2, marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual")
plt.title("Iteration vs Residual (Zernike-Based)")
plt.grid(True)
plt.show()
records = []

for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:
            current_zernike = Zernike(r, theta, a1, a2, a3)
            res_val = np.sum(np.abs(current_zernike - target))
            records.append((a1, a2, a3, res_val))

records = np.array(records, dtype=float)


residuals = records[:, 3]
iterations = np.arange(len(residuals))




min_index = np.argmin(residuals)

a1_min, a2_min, a3_min, res_min = records[min_index]

print("\nGlobal minima occurs at:")
print(f"  a1 = {a1_min}")
print(f"  a2 = {a2_min}")
print(f"  a3 = {a3_min}")
#print(f"  residual = {res_min}")
print(f"  iteration number = {min_index}")

#8th code
import numpy as np
import matplotlib.pyplot as plt

N = 256
x = np.linspace(-1, 1, N)
y = np.linspace(-1, 1, N)
X, Y = np.meshgrid(x, y)
r = np.sqrt(X**2 + Y**2)
theta = np.arctan2(Y, X)

def Zernike(r, theta, a1, a2, a3, a4, a5):
    return (a1 * (2*r**2 - 1) +
            a2 * r**2 * np.cos(2*theta) +
            a3 * r**2 * np.sin(2*theta) +
            a4 * (3*r**3 - 2*r) * np.sin(2*theta) +
            a5 * (3*r**3 - 2*r) * np.cos(2*theta))

a1_coeffs = np.linspace(4, 8, 10)
a2_coeffs = np.linspace(4, 8, 10)
a3_coeffs = np.linspace(4, 8, 10)
a4_coeffs = np.linspace(4, 8, 10)
a5_coeffs = np.linspace(4, 8, 10)

a1_t = 4.8
a2_t = 5.8
a3_t = 6.8
a4_t = 5.5
a5_t = 6.5

target = Zernike(r, theta, a1_t, a2_t, a3_t, a4_t, a5_t)

residuals_list = []
for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:
            for a4 in a4_coeffs:
                for a5 in a5_coeffs:

                    current_zernike = Zernike(r, theta, a1, a2, a3, a4, a5)
                    res_val = np.sum(np.abs(current_zernike - target))
                    residuals_list.append(res_val)

Res = np.array(residuals_list)
iteration = np.arange(len(Res))

plt.scatter(iteration, Res, s=2, marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual")
plt.title("Iteration vs Residual (Zernike-Based)")
plt.grid(True)
plt.show()

records = []
for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:
            for a4 in a4_coeffs:
                for a5 in a5_coeffs:

                    current_zernike = Zernike(r, theta, a1, a2, a3, a4, a5)
                    res_val = np.sum(np.abs(current_zernike - target))
                    records.append((a1, a2, a3, a4, a5, res_val))

records = np.array(records, dtype=float)

residuals = records[:, 5]
iterations = np.arange(len(residuals))

min_index = np.argmin(residuals)
a1_min, a2_min, a3_min, a4_min, a5_min, res_min = records[min_index]

print("\nGlobal minima occurs at:")
print(f"  a1 = {a1_min}")
print(f"  a2 = {a2_min}")
print(f"  a3 = {a3_min}")
print(f"  a4 = {a4_min}")
print(f"  a5 = {a5_min}")
print(f"  iteration number = {min_index}")

#9th code
import numpy as np
import matplotlib.pyplot as plt

N = 256
x = np.linspace(-1, 1, N)
y = np.linspace(-1, 1, N)
X, Y = np.meshgrid(x, y)
r = np.sqrt(X**2 + Y**2)
theta = np.arctan2(Y, X)

def Zernike(r, theta, a1, a2, a3, a4, a5, a6, a7):
    return (a1 * (2*r**2 - 1) +
            a2 * r**2 * np.cos(2*theta) +
            a3 * r**2 * np.sin(2*theta) +
            a4 * (3*r**3 - 2*r) * np.sin(2*theta) +
            a5 * (3*r**3 - 2*r) * np.cos(2*theta) +
            a6 * (6*r**4 - 6*r**2 + 1) +
            a7 * (r**3 * np.sin(3*theta)))

a1_coeffs = np.linspace(4, 8, 10)
a2_coeffs = np.linspace(4, 8, 10)
a3_coeffs = np.linspace(4, 8, 10)
a4_coeffs = np.linspace(4, 8, 10)
a5_coeffs = np.linspace(4, 8, 10)
a6_coeffs = np.linspace(4, 8, 10)
a7_coeffs = np.linspace(4, 8, 10)

a1_t = 4.8
a2_t = 5.8
a3_t = 6.8
a4_t = 5.5
a5_t = 6.5
a6_t = 6.2
a7_t = 7.1

target = Zernike(r, theta, a1_t, a2_t, a3_t, a4_t, a5_t, a6_t, a7_t)

residuals_list = []
for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:
            for a4 in a4_coeffs:
                for a5 in a5_coeffs:
                    for a6 in a6_coeffs:
                        for a7 in a7_coeffs:

                            current_zernike = Zernike(r, theta, a1, a2, a3, a4, a5, a6, a7)
                            res_val = np.sum(np.abs(current_zernike - target))
                            residuals_list.append(res_val)

Res = np.array(residuals_list)
iteration = np.arange(len(Res))

plt.scatter(iteration, Res, s=2, marker='.')
plt.xlabel("Iteration")
plt.ylabel("Residual")
plt.title("Iteration vs Residual (Zernike-Based)")
plt.grid(True)
plt.show()

records = []
for a1 in a1_coeffs:
    for a2 in a2_coeffs:
        for a3 in a3_coeffs:
            for a4 in a4_coeffs:
                for a5 in a5_coeffs:
                    for a6 in a6_coeffs:
                        for a7 in a7_coeffs:

                            current_zernike = Zernike(r, theta, a1, a2, a3, a4, a5, a6, a7)
                            res_val = np.sum(np.abs(current_zernike - target))
                            records.append((a1, a2, a3, a4, a5, a6, a7, res_val))

records = np.array(records, dtype=float)

residuals = records[:, 7]
iterations = np.arange(len(residuals))

min_index = np.argmin(residuals)
a1_min, a2_min, a3_min, a4_min, a5_min, a6_min, a7_min, res_min = records[min_index]

print("\nGlobal minima occurs at:")
print(f"  a1 = {a1_min}")
print(f"  a2 = {a2_min}")
print(f"  a3 = {a3_min}")
print(f"  a4 = {a4_min}")
print(f"  a5 = {a5_min}")
print(f"  a6 = {a6_min}")
print(f"  a7 = {a7_min}")
print(f"  iteration number = {min_index}")
print(f"  minimum residual = {res_min}")